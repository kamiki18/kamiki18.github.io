---
layout: default
title: IIR study
---

## scipy.signal.filter でのごにょごにょ。



NanoVNA の入力段はダイレクトコンバージョンで 5kHz の IF に落し、そこから 48ksps の ADC でデジタル値にしたあと 5kHz のサイン波/コサイン波と内積してパワー、位相を入手している。
現状の IF 段のフィルタは簡素なものだが、使用されている ADC TLV320AIC3204 は 5段の IIR フィルタまたは 25 段の FIR フィルタが内蔵できるようになっている。

その IIR フィルタの設計について。もちろん作るのは 5kHz の BPF になる。

ところでざっと設計したあとで知ったことだが、IF は 5kHz からけっこうバラつく:

![生のfilter()結果](/image/elliptic3u.pngtodo.md "hello")

これは 50kHz 〜 1.5GHz までの 1Hz ステップでの IF の 5kHz からのズレをあらわしたヒストグラムである。
±60Hz までは確実に通過させるべき状況であった。



まず scipy の iirfilter を使って IIR の BPF を手に入れる:

~~~ python

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt

sos = signal.iirfilter(3, [4950.0/24000, 5050.0/24000], rs=70, rp=0.1, btype='band', analog=False, ftype='ellip', output='sos')

~~~

は 2次のフィルタを 3つ繋げた形の elliptic 型 BPF になる。
それぞれのフィルタの途中をピックアップしつつ周波数特性を表示してみると:

![生のfilter()結果](/image/elliptic3u.pngtodo.md "hello")

最終的な緑のフィルタはとても立派なものなのだが、初段、青のフィルタの段階で 40dB も叩き落としているのはいただけない。
係数を適当にスケーリングしてこうした:

![生のfilter()結果](/image/elliptic3u.pngtodo.md "hello")

5050Hz あたりが 2段通過時点でゲインを持ってしまっているので 30Hz 上に強烈な信号があって飽和すると問題だが、
5kHz の信号を減衰させて増幅とかやって情報落ちするよりは良いだろう。
山頂付近の形状、群遅延の様子:

![てっぺん付近](/image/elliptic3u.pngtodo.md "hello")

5000Hz 前後で群遅延が平坦になるように、地味に係数を調整してあったりする。
... のだが、通過帯域はともかく群遅延のほうに ± 60Hz もの平坦性はなかった。もうちょっと幅は広く取らないといけない。


こちらは Bessel 型 BPF の様子。

~~~ python

sos2 = signal.iirfilter(3, [4850.0/24000, 5150.0/24000], btype='band', analog=False, ftype='bessel', output='sos')

~~~

![てっぺん付近](/image/elliptic3u.pngtodo.md "hello")


Bessel 型は LPF の時は群遅延の最大平坦という特徴があるが、HPF や BPF にはそんなもんはない。多少補正して、

![てっぺん付近](/image/adjust.png "hello")

![てっぺん付近拡大](/image/adjust.png "hello")

として使う。... のだが、いずれにしても平坦領域不足である。リテイク。

NanoVNA の 0.3.1 期のソースに含まれていたフィルタ 2 題、ベッセル型 2 次とエリプティック型 5 次。


ベッセル型 2 次のほうはピークゲインと 5kHz のターゲットゲインの調整に気くばり感(なるほど)だが、
エリプティック型のほうは 4つ目と 5つ目のステージの係数調整抜けてるかも。

ちなみにエリプティック型のほうであっても ±100Hz弱の平坦(というほどでもないが)っぽいところが確保されていた。













static const uint8_t conf_data_iir2[] = {
  7,            /* group delay [ms] */
  3,



NanoVNA 0.3.1 以前の tlv320aic3204.c には TLV320AIC3204 の miniDSP 用の BPF の実験コードが入っていた (0.4.0 では削除されている)。

~~~ c
const uint8_t adc_filter_config[] = { ... }
~~~

の部分である。これをアプリケーションガイド (TLV320AIC3204 Application Reference Guide SLAA577) の
Biquad section (p27) とデータのバイトオーダー(同 p143) を見ながら $H(z)$ を再生する。

\\[ H(z) = \frac{0.02 + 0.0408z^{-1} + 0.02z^{-2}}{1 - 1.46z^{-1} + 0.888z^{-2}} \frac{0.189 - 0.377z^{-1} + 0.189z^{-2}}{1 - 1.54z^{-1} + 0.897z^{-2}} \\]

これは scipy の signal./* bb, aa = signal.ellip(2, 0.1, 100, (4500.0/24000, 5500.0/24000), 'bandpass') */


sos = np.array( [
   [ 0.02038348, 0.04076695, 0.02038348, 1.00000000, -1.46197867, 0.88831782],
   [ 0.18854105, -0.37708211, 0.18854105, 1.00000000, -1.54453158, 0.89706874] ] )




scipy によるフィルタの設計。ipython3 から、          # python コメントは space x2 # + space + 空白以外の文字、になる。フォーマットやかましい。

signal.iirfilter の引数
   (17, [50, 200], rs=60, btype='band',analog=True, ftype='cheby2')
    次数
        ナイキスト周波数基準で
    rp = 通過帯域リプル。
    rs = 阻止帯域阻止量。
    analog  Trueでアナログフィルタ。なしでデジタル。b,a 表記の次数順が変わることに注意。

冒頭のおまじない:

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
from matplotlib import ticker
