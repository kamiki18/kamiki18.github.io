---
layout: default
title: test page
---

## Fraction().limit_denominator でのごにょごにょ。


NanoVNA の出力やダイレクトコンバージョン用 LO のクロックは fractional PLL の Si5351 で作成される。

その分数分周の係数決めだが、こういっては何だがあまり出来はよくない。
adafruits や arduino の Si5351 ライブラリの出来も似たりよったりなのだが。
周波数偏差の最悪値が数十ヘルツあることに甘えて平均的にも数十ヘルツの誤差があるコードになっているな。

NanoVNA の場合、ワーストケースは 1.456 GHz 付近で起きる。

26MHz の原発を使って 7倍高調波で 1.456 GHz を作るためには Multisynth の分周を 4 に固定して

   26[MHz] * (32 + 0/1048575)/4 * 7       =  1456.000000 [MHz]

という係数を使う。この周波数の隣は明らかに

   26[MHz] * (32 + 1/1048575)/4 * 7       =   1456.00004339222 [MHz]

で、ここに 43.4 [Hz] のギャップがある。つまり最悪 21.7 [Hz] の偏差はやむをえない。

同様に PLL を 832MHz に固定した状況において、ワーストケースは 520 MHz 付近の ofrec において生じる:

       832/(8 + 0/1048575) * 5 = 520.000000 [MHz]
       832/(8 + 1/1048575) * 5 = 519.999938 [MHz]

なので 62Hz のギャップがあり、つまり 31 [Hz] の偏差は避けがたい。
ただしこちらは PLL 動かしてよいのなら、出力周波数の純度を犠牲にしてではあるが、偏差を減らすことはできる。

ofrec が 1456.005 MHz 付近にある現在の偏差状況:

freq_freq1455-1455.png
freq_ofreq1455-1455.png

真面目に追い詰めるとこうなる:

freqn_freq1455-1455.png
freqn_ofreq1455-1455.png

横軸の違いに注意。freq のほうの形が一般的な状況で、ofreq が最悪値の状況である。

m + n/d という係数は微細な周波数決定に n * d の自由度がある。そして実際、有理近似によってこの自由度を使い切ることができる。

1.5 GHz を 1 Hz 毎に表現するとすると 30bit 必要になるが、d は 20bit しかない。
つまり n が 10bit 以上あれば表現力に問題なく、1024/1048575 = 0.1% で、99.9% の周波数では誤差 1 Hz 以下に設定できる。

ランダムテストしかしてなかったので、いつまでたってもワーストケースを発見できないという罠に嵌まっていた。
全数検査に入って初めて気づいたり。


### IF のブレ

さて、freq, ofreq のブレは 数百メガヘルツの数十ヘルツで、原発 26MHz が 1ppm 前後の精度だと思えば、無視しようと思えば思えないこともない。
シグナルジェネレータやスペクトラムアナライザとして使う時はもちろん気になる。
が、ofreq - freq = IF となる IF も数十ヘルツずれてくる:

freq_if1455-1455.png
freqdev_if.png

50kHz 〜 1.5Gz での IF の 5kHz からのズレ。


フィルタを書く上で大問題なので、MCLK を動かしてみた。

freqn3_if1455-1455a.png

かわりに MCLK が 8MHz から大幅にずれる。5KHz にとっての 60Hz は 8MHz にとっての 96kHz だから。

freqn3_mclk1455-1455.png

現状での MCLK のブレは 0.3 Hz かそこら:


50kHz 〜 1.5Gz での MCLK の 8MHz からのズレ。

なので大胆。




