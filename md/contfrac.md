

# fractional PLL における rational approximation


Si5351 の PLL 段出力 $ f_{PLL} $, それにクロック出力  $ f_{out1,2,3...} $ は入力 $ f_{c} $ (NanoVNA の場合で 26MHz ) を使って
\\[ f_{PLL} = fc * (m_p + n_p/d_p) \\]
\\[ f_{out} = f_{PLL} /(m_m + n_m/d_m) / R \\]
と書ける。
$ m_p = 15..99, n_p = 0..(2^20-1), d_p = 0..(2^20-1), m_m = 4..1800, n_m = 0..(2^20-1), d_m = 0..(2^20-1), R = 2^(0..7) $ だそうな。

さて。たとえば目標周波数 $ freq = 10.000189[MHz] $ の場合、$ freq, ofreq, MCLK $ それぞれについて現状、 

\\[ f_{PLL} = 26[MHz] * 32 = 832[MHz],  \\]
\\[ freq = 832[MHz] / (83 + 124019 / 625011) / 1  = 10000189.08 [Hz]  \\]
\\[ ofreq = 832[MHz] / (83 + 98082 / 625324) / 1 =  10005189.00 [Hz]  \\]
\\[ MCLK  = 832[MHz] / (104 + 0 / 1) / 1 = 8 [MHz] \\]

という設定をしている。Si5351 的には $ freq $ の場合で
\\[ 
    10000189.0000176 = 832000000 / (83 + 13149 / 66266),
    10000188.9993385 = 832000000 / (83 + 530 / 2671),
    10000189.0201529 = 832000000 / (83 + 429 / 2162),
 \\]
 といった定数が存在するわけで、そのあたりもうちょい追い込もうという話。




10000188.9993 =  832000000 / (83 + 530/2671)



とりあえず $ f_{PLL} 、



は 
   PLL段         fc * ( m + n/d)          m = 15..99, n = 0..(2^20-1), d = 0..(2^20-1).   // pll = 600..900MHz.
   Multisync段   pll / (div + n/d) / R    div = 4..900, n = 0..(2^20-1), d = 0..(2^20-1), R = 2^(0..7)
   fout = 2.5kHz 〜 200MHz.
   しかして pll < 1200MHz, fout < 300MHz で使ってる。 

たとえば freq = 10.000189 MHz に対して
       PLL0 =  832 MHz (固定?),
       PLL1 =  832 MHz,
       10000189.08 = si5351_setupMultisynth(1;  (83 + 124019 / 625011) * 1 )
       10005189.00 = si5351_setupMultisynth(0;  (83 + 98082 / 625324) * 1 )
        8000000.00 = si5351_setupMultisynth(0;  (104 + 0 / 1) * 1 )
を作成している。ちなみに
       10000188.9993 =  832000000 / (83 + 530/2671)
だから、Si5351.c の計算は最適値ではない。

gcd 列は 83, 5, 25, 4, 4, 1, 24, 1, 1, 1, 3, 1, 2. で途中で打ち切って、
    832000000  / (  1/5 + 83)  = 10000000.0,
    832000000  / (  1/(1/25 + 5) + 83)  = 10000190.7850806,
    832000000  / (  1/(1/(1/(1/4 + 4) + 25) + 5) + 83)  = 10000189.02015,
    832000000  / (  1/(1/(1/(1/(1 + 4) + 4) + 25) + 5) + 83)  =  10000188.9993385,
    832000000  / (  1/(1/(1/(1/(1/(1/24 + 1) + 4) + 4) + 25) + 5) + 83)  =   10000189.0000176,
つまり
    10000189.0000176 = 832000000 / (83 + 13149 / 66266),
    10000188.9993385 = 832000000 / (83 + 530/2671)
    10000189.0201529 = 832000000 / (83 + 429/2162)

130.005001 MHz での最良近似は gcd列 6, 2, 1, 1, 161, 1, 6, 1, 11, 1, 2, 4, 2, 1, 3, 10,
    832000000  / (  1/(1/(1/(1/(1/(1/6 + 1) + 161) + 1) + 1) + 2) + 6)  = 130005001.511446
                                       7/6
				           1133/7
				             1140/1133
				                  2273/1140
				                       5686/2273
				                           36389/5686
    832000000  / (6 + 2273/5686) = 130005001.511446.
    
100〜150 で 6倍、i.e.  PLL = 600〜900MHz とすると、
                       PLL = 130.005001 * 6 = 780.030006 MHz,
		       26 MHz からの gcd 列は 30, 866, 2, 37, 5, 9, 1, 3.
     26000000 * ( 30 + 1/(866 + 1/(2 + 1/(37 + 1/(5 + 1/(9 + 1/(1 + 1/3))))))) =  780030006,
     26000000 * ( 30 + 15003/13000000 )  =  780030006,
     26000000 * ( 30 + 1/(866 + 1/(2 + 1/(37 + 1/5 )))) =  780030005.999975,      // (30 + 377/326668)
                                       5/186
				186/377
			377/326668
		  
     26000000 * ( 30 + 1/(866 + 1/(2 + 1/(37))))         = 780030006.001200,      //  (30 + 75/64987)
                                37/75
                       75/64987)
     26000000 * ( 30 + 1/(866 + 1/(2)))                =   780030005.770340,      //  (30 + 2/1733)
     26000000 * ( 30 + 1/(866 ))                        =  780030023.094688       //  (30 + 1/866)

150〜300 で 4倍、i.e.  PLL = 600〜1200MHz として使い、fo を得ている。
200〜300 がおかしいのはこいつか。200〜225 は fo がおかしく、225〜300 は fo, pll ともにおかしい。

MCU clock と f+Δ を PLL0, f を PLL1 とする。



freq =  130.000001 MHz だと
        PLL0 = 780.029984 MHz,
        PLL1 = 780 MHz,
        130000000.00 = si5351_setupMultisynth(1;  (6 + 0 / 1) * 1)                100MHz以上で 1/6 固定演算。 150MHz以上では 1/4 固定。 
        130004997.33 = si5351_setupMultisynth(0;  (6 + 0 / 1) * 1)
          8000000.00 = si5351_setupMultisynth(1;  (97 + 500000 / 1000000) * 1)

ついでに freq =  130.005001 MHz では
        PLL0 = 780.06 MHz,
        PLL1 = 780.029984 MHz,
        130004997.33 = si5351_setupMultisynth(1;  (6 + 0 / 1) * 1)
        130010000.00 = si5351_setupMultisynth(0;  (6 + 0 / 1) * 1)
          7999999.84 = si5351_setupMultisynth(1;  (97 + 503750 / 1000000) * 1)  // うーん、頭悪いな。

で PLL優先、8MHz が狂いついでにそもそも 4Hz もくるってる。freq =  130.005002 MHz で
        PLL0 = 780.06 MHz,
        PLL1 = 780.029984 MHz,
        130004997.33 = si5351_setupMultisynth(1;  (6 + 0 / 1) * 1)                  // ADC 的には   130005001.392656 Hz に見える。
        130010000.00 = si5351_setupMultisynth(0;  (6 + 0 / 1) * 1)                  //              130010004.062813 Hz なので差は 5002.67Hz.
          7999999.75 = si5351_setupMultisynth(1;  (97 + 503751 / 1000000) * 1)
だから、出力周波数は 130.005001 MHz と同じなのに ADC クロック(と CPU クロック) だけ異なる。



I2S のマスタクロックは どっちが定めてんだ? ADC が決めてる?  // デフォルトでは ADC 的には入力だそうな。


高調波の使い方
   50kHz〜500kHz
     band0               PLL A (832MHz 固定) で freq, ofreq, MCLK とも扱う。
     R = 64.
   500kHz〜4MHz
     band0
     R = 8.
   4MHz〜100MHz         // Multisynth 側で分数分周で使うには 100MHz 以下でなければならない。
     band0                 で、R を除く分周最大は 1800 までなので 832MHz / 1800 = 462kHz が下限。  //   (m + n/d) の m は 900 まで?
   100〜150MHz          // Multisynth 側でいじるには 150MHz 以下でなければならない。
     band1               PLL A で ofreq,  PLL B で freq, MCLK を扱う。 // 逆にすべきでは? PLL B で freq, PLL A で ofreq と MCLK.
     div = 6.            // 必須。112.5MHz 以上は整数分周のみ。  //  「112.5MHzを越える周波数は 2つまで」の記述より。112.5以上で multisynth が不自由になる意。 
   150〜200MHz
     band2               PLL A で ofreq,  PLL B で freq, MCLK を扱う。 
     div = 4.            // 必須。アプリケーションノート AN619 6p 4.2.2 に明記。
   200〜225MHz
     band2               PLL A で ofreq,  PLL B で freq, MCLK を扱う。Si5351 の Fout が規格外になることに注意。
     div = 4.
   225〜300MHz
     band2               PLL A で ofreq,  PLL B で freq, MCLK を扱う。Si5351 の Fout と Fpll が規格外になることに注意。
     div = 4.
   300〜900MHz
     band2
     freq /= 3;          //  i.e.  3Hz ステップ。 100〜300MHz
     ofreq /= 5;                                   60〜180MHz
   900〜1500MHz,
     band2
     freq /= 5;          //  i.e.  5Hz ステップ。  180〜300MHz
     ofreq /= 7;                                   128〜214MHz.

へー。

   PLL段         fc * ( m + n/d)          m = 15..99, n = 0..(2^20-1), d = 0..(2^20-1).   // pll = 600..900MHz.
   Multisync段   pll / (div + n/d) / R    div = 4..900, n = 0..(2^20-1), d = 0..(2^20-1), R = 2^(0..7)
   fout = 2.5kHz 〜 200MHz.

26000000 * ( m + n/d) =  1200MHz 以下で 4Hzステップ  m = 46.1538
1155000004/4 = 288750001 Hz を作りたいとする。
  PLL1 = 26000000 * (44 + 343750 / 812500) = 1155000000 Hz,
  freq = PLL / 4 = 288750000 Hz,
  PLL0 = 26000000 * (44 + 344375 / 812500) = 1155020000 Hz,
  ofreq = PLL0 / 4 = 288755000 Hz,
  MCLK =  PLL1 / (144 + 375000 / 1000000) = 8000000 Hz.
... だめじゃん。

1155000004/26000000 の gcd 列 44, 2, 2, 1, 3, 9615, 8, 1, 2. つまり、
     26000000 * ( 44 + 1/(2 + 1/(2 + 1/(1+ 1/(3+ 1/(9615 + 1/(8 + 1/(1+ 1/2)))))))) = 1155000004,
     26000000 * ( 44 + 1/(2 + 1/(2 + 1/(1+ 1/3)))) = 1155000000,                                   これで打ち切ってるが、
     26000000 * ( 44 + 1/(2 + 1/(2 + 1/(1+ 1/(3+ 1/9615 ))))) =  1155000004.00005,
                                           9615/28846
				     28846/38461
			      38461/105768
		       105768/249997
     26000000 * (44 + 105768/249997) = 1155000004.00005.   これも OK じゃんね。
1155000004.00005/8000000 の gcd 144,2,1,1,1,31248,1,60,1 ...
     1155000004.00005 / ( 144 + 1/(2 + 1/(1 + 1/(1 + 1/(1 + 1/(31248 + 1/(1 + 1/(60 + 1)))))))) =  8000000.
     1155000004.00005 / ( 144 + 1/(2 + 1/(1 + 1/(1 + 1/(1 + 1/(31248)))))) =  7999999.99999913.
     1155000004.00005 / ( 144 + 1/(2 + 1/(1 + 1/(1 + 1)))) = 8000000.02770597.

     26000000 * (44 + 105768/249997) / 8000000 = 26000000 * 44 / 8000000 + 26000000 * 105768/(249997 *  8000000)
                                               = 26000000 * 44 * 249997/ (249997 * 8000000) + 26000000 * 105768/(249997 *  8000000)
                                               = (26000000 * 44 * 249997 + 26000000 * 105768)/ (249997 * 8000000)
                                               = 288746536000000/1999976000000
					       =  36093317 / 249997
					       = 144 + 93749/249997.   OK.
    1155000004.00005 / (144 + 93749/249997) = 8000000 Hz.
    
    26MHz * ( m + n/d) に対し、
    26MHz * ( m + n/d) / 8MHz = 26MHz * (m * d + n) / (d * 8MHz) = (13 * m * d + 13 * n) / (4 * d),
   [26MHz * ( m + n/d)] / [(13 * m * d + 13 * n) / (4 * d)] = 8MHz,
   故に 4 * d が 2^20 を越えないなら、どのような m,n,d についても 8MHz ちょうどにすることができる。          <--.
   d が奇数なら n は偶数、m が偶数なら少なくとも 2 で割れる。
   d が偶数なら n は偶数なのでいずれにせよ 2ベキで割れることはない。


4.001101 MHz 時、832 MHz を使って 832000000 / (207 + 290161 / 307777) = 4001101 Hz という計算してる。


          4006101.00 = si5351_setupMultisynth(0;  (207 + 684273 / 1001525) * 1)
          4001101.00 = si5351_setupMultisynth(0;  (207 + 290161 / 307777) * 1)
          8000000.00 = si

    freq = 26MHz * ( m + n/d) に対し、ofreq = freq + 5kHz とすると
    ofreq = 26MHz * (m + n/d + 1/5200) = 26MHz * (m + (n * 5200 + d)/(d * 5200))
    んー、(n * 5200 + d) と (d * 5200) が既約でない可能性はほぼないとして、d * 5200 <= 2^20 - 1  から d <= 201.65 かぁ。
    さすがに精度悪い。255.030017MHz で 601Hz ずれた。
    
    freq = 832MHz / ( m + n/d) に対し、ofreq = freq + 5kHz の場合は、
    ofreq = 832MHz / ( m + n/d) + 5kHz = 832MHz / k を k について解いて
       k = 832MHz / (832MHz / ( m + n/d) + 5kHz)  = 832MHz * (m + n/d) / (832MHz + (m + n/d) * 5kHz) = A + B / (832MHz + (m + n/d) * 5kHz) として以下、
         = A + (B * d)/ (832MHz * d + (m * d + n) * 5kHz)
    つまり	 
       832000000 * d + (m * d + n) * 5000 < 1048575. ... むりじゃね。




TLV は 左が IN2, 右が IN1, IN3 切替え。
const int8_t gain_table[] = {
  5,5,  // 0 ~ 300MHz      //  0.3.1 では 0      gain は 0.5dB ステップ。i.e. +0〜47.5dB.
  42, 40,// 300 ~ 600MHz                 40      300-900MHz で freq /= 3, ofreq /= 5.
  52,50,// 600 ~ 900MHz                  50
  80,78, // 900 ~ 1200MHz                75      900-1500MHz で freq /= 5, ofreq /= 7.
  90,88, // 1200 ~ 1400MHz               85
  95,93  // 1400MHz ~                    95      95は max値。つまり足りてないかも。
};

なので reference のがゲイン大きいな?

ただいまテスト中。

* hoge
* huga

｜javascript《ジャワスクリプト》のテスト

数式 $ y = x^{2}_1 $ と数式

\\[ y = \int^{z=\\infty}_{x =0} x^3 dx  \\]

のテスト。$ y = x^{64}_3 $ でおけ?

\\[
  \frac{\pi}{2} =
  \left( \int_{0}^{\infty} \frac{\sin x}{\sqrt{x}} dx \right)^2 =
  \sum_{k=0}^{\infty} \frac{(2k)!}{2^{2k}(k!)^2} \frac{1}{2k+1} =
  \prod_{k=1}^{\infty} \frac{4k^2}{4k^2 - 1}
\\]

（<span lang="en"><i>E</i> = <i>mc</i><sup>2</sup></span>）

エネルギーと質量には $ E = mc^2 $ の関係がある。

\\[x = {-b \\pm {}^{3}\sqrt{b^2-4ac} \\over 2a}. \\]
